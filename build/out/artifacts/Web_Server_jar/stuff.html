<html>
<link rel="stylesheet" href="css.css"/>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script src="chart.js"></script>
<script src="gauge.js"></script>
<h1>Pitview Web Client</h1>
<input type="checkbox" id="updateCB" checked>Live Update
</html>
<input type="checkbox" id="scrollLock" checked>Auto-scroll Log</input>
<textarea id="logs"></textarea>

<div>
	<span id="gauge-value" style="display:block;font-size:2em"></span>
    <canvas class='dial' width='300' height='200' value="0.5"></canvas>
    <table>
        <tr>
            <td>
                <label style='display:block;'>MPG</label>
                <canvas class='graph' width='600' height='300'></canvas>
            </td>
            <td>
                <label style='display:block;'>Battery Voltage</label>
                <canvas class='graph2' width='600' height='300'></canvas>
            </td>
        </tr>
        <tr>
            <td>
                <label style='display:block;'>Fuel Remaining</label>
                <canvas class='graph3' width='600' height='300'></canvas>
            </td>
        </tr>
    </table>
</div>
<script>
    var data;
    var historicData = [];
    var MAX_HISTORY = 21, UPDATE_PERIOD = 500;
    var logs = "", lastLog = "";
    var isRunning=true;
	var gauges=[new Gauge($('.dial')[0])];
    var type=["mpg","batteryVoltage","fuelRemaining"];
    getData();
    function getData() {
        try {
            $.ajax({
                type: "post",
                url: "http://localhost/ajax",
                data: "{" + "'requesttype=last'" + "}",
                success: function (d) {
                    updatedata(d);
                },
                datatype: "json"
            });
        } catch (e) {
            console.log(e);
        }
        if(isRunning) {
            setTimeout(function () {
                getData();
            }, 750);
        }
    }
    function updatedata(d) {
        var el = document.createElement('p');
        el.innerHTML = d;
        console.log(d);
        if (lastLog != d) {
            lastLog = d;
            logs += "\n" + d;
            $("#logs").val(logs);
            if ($('#scrollLock')[0].checked) {
                $("#logs")[0].scrollTop = $("#logs")[0].scrollHeight;
            }
        }
        //$('html')[0].appendChild(el);
        try {
            data = JSON.parse(d);
            data["fuelRemaining"] *= 100;
        } catch (e) {
            data = {mpg: 0.0, batteryVoltage: 0.0, fuelRemaining: 0.0};
        }
        if (historicData.length >= MAX_HISTORY) {
            historicData.shift();
        }
        historicData.push(data);
		updateDial(0,$('.dial')[0],gauges[0],"#gauge-value");
        //updateDial($('.dial')[0].getContext('2d'), $('.dial')[0].width / 2, $('.dial')[0].height / 2, $('.dial')[0].width / 4, data.mpg / 100, 0, "red");
        if ($('#updateCB')[0].checked) {
            drawGraph(0, $('.graph')[0], MAX_HISTORY, true, "%");
            drawGraph(1, $('.graph2')[0], MAX_HISTORY, false, "v");
            drawGraph(2, $('.graph3')[0], MAX_HISTORY, true, "%");
        }
    }
    function drawGraph(dataIndex, element, historyCount, isPercent, unit) {
        Chart.defaults.global.animation = false     ;
        //Chart.defaults.global.tooltipTemplate= "<%= value %>"+unit;
        Chart.defaults.global.showTooltips = false;
        Chart.defaults.global.scaleLabel = "<%=value%>" + unit;
        //$('.graph').replaceWith('<canvas class="graph" width="'+element.width+'" height="'+element.height+'"></canvas>');
        var ctx = element.getContext("2d");
        var labels = [], datavalues = [];

        try{
            if(element.chart.datasets[0].points.length<historyCount){
                throw new RangeException();
            }
            for (i = 1; i < historyCount && i < historicData.length; i++) {
                //if(i-1<element.chart.datasets[0].points.length) {
                    element.chart.datasets[0].points[i - 1].value = historicData[MAX_HISTORY - historyCount + i][type[dataIndex]];

                /* }else{
                    var x=((UPDATE_PERIOD * (Math.min(historyCount, historicData.length) - i - 1)) / 1000);
                    var y=historicData[MAX_HISTORY - historyCount + i][type];
                    var label=(i < historicData.length - 1 ? "-" : "") +
                            ((UPDATE_PERIOD * (Math.min(historyCount, historicData.length) - i - 1)) / 1000) + "s";
                    element.chart.addData([x,y],label);
                }*/
            }
            element.chart.update();
        } catch (ex) {
            for (i = 0; i < historyCount && i < historicData.length; i++) {
                labels.push((i < historicData.length - 1 ? "-" : "") + ((UPDATE_PERIOD * (Math.min(historyCount, historicData.length) - i - 1)) / 1000) + "s");
                datavalues.push(historicData[MAX_HISTORY - historyCount + i][type[dataIndex]]);
            }
            var data = {
                labels: labels,
                datasets: [
                    {
                        label: "My First dataset",
                        fillColor: "rgba(255, 153, 0,0.5)",
                        strokeColor: "rgba(220,220,220,1)",
                        pointColor: "rgba(220,220,220,1)",
                        pointStrokeColor: "#fff",
                        pointHighlightFill: "#fff",
                        pointHighlightStroke: "rgba(220,220,220,1)",
                        data: datavalues
                    }
                ]
            }, options = {
                scaleOverride: isPercent,
                scaleStartValue: 0,
                scaleStepWidth: 10,
                scaleSteps: 10,
                ///Boolean - Whether grid lines are shown across the chart
                scaleShowGridLines: true,

                //String - Colour of the grid lines
                scaleGridLineColor: "rgba(0,0,0,.05)",

                //Number - Width of the grid lines
                scaleGridLineWidth: 1,

                //Boolean - Whether to show horizontal lines (except X axis)
                scaleShowHorizontalLines: true,

                //Boolean - Whether to show vertical lines (except Y axis)
                scaleShowVerticalLines: true,

                //Boolean - Whether the line is curved between points
                bezierCurve: true,

                //Number - Tension of the bezier curve between points
                bezierCurveTension: 0.4,

                //Boolean - Whether to show a dot for each point
                pointDot: true,

                //Number - Radius of each point dot in pixels
                pointDotRadius: 4,

                //Number - Pixel width of point dot stroke
                pointDotStrokeWidth: 1,

                //Number - amount extra to add to the radius to cater for hit detection outside the drawn point
                pointHitDetectionRadius: 20,

                //Boolean - Whether to show a stroke for datasets
                datasetStroke: true,

                //Number - Pixel width of dataset stroke
                datasetStrokeWidth: 2,

                //Boolean - Whether to fill the dataset with a colour
                datasetFill: true,

                //String - A legend template
                legendTemplate: "<ul class=\"<%=name.toLowerCase()%>-legend\"><% for (var i=0; i<datasets.length; i++){%><li><span style=\"background-color:<%=datasets[i].lineColor%>\"></span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%></ul>"

            };

            element.chart=new Chart(ctx).Line(data, options);
        }
    }
	function updateDial(dataIndex,element,gaugeNew,valueTextID){
		var opts = {
			lines: 12, // The number of lines to draw
			angle: 0.15, // The length of each line
			lineWidth: 0.44, // The line thickness
			pointer: {
			length: 0.9, // The radius of the inner circle
			strokeWidth: 0.035, // The rotation offset
			color: '#000000' // Fill color
			},
			limitMax: 'false',   // If true, the pointer will not go past the end of the gauge
			colorStart: '#6FADCF',   // Colors
			colorStop: '#8FC0DA',    // just experiment with them
			strokeColor: '#E0E0E0',   // to see which ones work best for you
			generateGradient: true
		};
		var target = element; // your canvas element
		var gauge;
		if(gaugeNew==null){
			gauge= new Gauge(target).setOptions(opts); // create sexy gauge!
		}else{
			gauge=gaugeNew;
		}
		gauge.maxValue = 100; // set max gauge value
		gauge.animationSpeed = 10; // set animation speed (32 is default value)
		gauge.setTextField($(valueTextID)[0]);
		gauge.set(historicData[historicData.length-1][type[dataIndex]]); // set actual value
	}
    /*var el = $('.dial')[0];
    var dial = el.getContext('2d');
    dial_draw_bg(dial, "Testing", {x: $('.dial')[0].width / 2, y: $('.dial')[0].height / 2});
    function dial_draw_bg(canvas, title, center) {
        canvas.clearRect(0, 0, canvas.canvas.width, canvas.canvas.height);
        dial.strokeStyle = 'gray';
        dial_inc_lines(dial, center.x, center.y, center.x / 2, 16, Math.PI, 0, true);
        dial.arc(center.x, center.y, center.x / 2, Math.PI, 0);
        dial.lineWidth = '1';
        dial.fillStyle = 'lightgray';
        dial.fill();
        dial.stroke();

        dial.fillStyle = "black";
        dial.font = "16px Arial";
        dial.fillText(title, center.x - title.length * 4, center.y + 20);

        dial.strokeStyle = 'gray';
        dial_inc_lines(dial, center.x, center.y, center.x / 2, 16, Math.PI, 0, true);
    }
    var goingup = true;
    var cnt = 0;

    function updateDial(canvas, x, y, r, value, end, color) {
        var start = Math.PI;
        dial_draw_bg(canvas, "Testing", {x: x, y: y});
        canvas.beginPath();
        dial.lineWidth = '1';
        var sx = x + r * -.1 * Math.cos(start + value * (start - end)), sy = y + r * -.1 * Math.sin(start + value * (start - end));
        canvas.moveTo(sx, sy);
        var ex = x + r * .9 * Math.cos(start + value * (start - end)), ey = y + r * .9 * Math.sin(start + value * (start - end));
        canvas.lineTo(ex, ey);
        canvas.strokeStyle = color;
        canvas.lineWidth = '4';
        canvas.stroke();
        goingup = (cnt < 0 || cnt > 1) ? !goingup : goingup;
        cnt = (goingup) ? cnt + .01 : cnt - .01;
    }
    function dial_inc_lines(canvas, x, y, r, n, start, end, sign) {
        dial.beginPath();
        dial.lineWidth = '1';
        for (i = 0; i <= n; i++) {
            var theta = start + (start - end) / n * i;
            canvas.moveTo(x, y);
            var rr = r;
            if (sign && (i == 0 || ((i == n / 2 || i == n / 4 || i == n * 3 / 4) && n % 2 == 0) || i == n))
                rr = r * 1.2;
            var endx = rr * Math.cos(theta) + x, endy = rr * Math.sin(theta) + y;
            canvas.lineTo(endx, endy);
            canvas.stroke();
        }
    }*/
</script>
</html> 